"use client";

import { useMemo, useState } from "react";
import ToolPageLayout from "../../../components/ToolPageLayout";

type Schema =
  | { kind: "string"; nullable: boolean }
  | { kind: "number"; isInteger: boolean; nullable: boolean }
  | { kind: "boolean"; nullable: boolean }
  | { kind: "null"; nullable: true }
  | { kind: "array"; item: Schema; nullable: boolean }
  | { kind: "object"; fields: Record<string, Schema>; nullable: boolean }
  | { kind: "any"; nullable: boolean };

type Annotation = "kotlinx" | "none";

const safeJsonParse = (text: string): unknown => {
  try {
    return JSON.parse(text);
  } catch {
    return null;
  }
};

const isRecord = (value: unknown): value is Record<string, unknown> =>
  typeof value === "object" && value !== null && !Array.isArray(value);

const mergeSchemas = (a: Schema, b: Schema): Schema => {
  const nullable = a.nullable || b.nullable;

  if (a.kind === "null") return { ...b, nullable: true };
  if (b.kind === "null") return { ...a, nullable: true };

  if (a.kind === "any" || b.kind === "any") return { kind: "any", nullable };
  if (a.kind !== b.kind) return { kind: "any", nullable };

  if (a.kind === "string" && b.kind === "string") return { kind: "string", nullable };
  if (a.kind === "boolean" && b.kind === "boolean") return { kind: "boolean", nullable };
  if (a.kind === "number" && b.kind === "number") return { kind: "number", isInteger: a.isInteger && b.isInteger, nullable };

  if (a.kind === "array" && b.kind === "array") return { kind: "array", item: mergeSchemas(a.item, b.item), nullable };

  if (a.kind === "object" && b.kind === "object") {
    const keys = Array.from(new Set([...Object.keys(a.fields), ...Object.keys(b.fields)])).sort();
    const fields: Record<string, Schema> = {};
    for (const key of keys) {
      const left = a.fields[key] ?? { kind: "null", nullable: true };
      const right = b.fields[key] ?? { kind: "null", nullable: true };
      fields[key] = mergeSchemas(left, right);
    }
    return { kind: "object", fields, nullable };
  }

  return { kind: "any", nullable };
};

const inferSchema = (value: unknown): Schema => {
  if (value === null) return { kind: "null", nullable: true };

  if (typeof value === "string") return { kind: "string", nullable: false };
  if (typeof value === "boolean") return { kind: "boolean", nullable: false };
  if (typeof value === "number") return { kind: "number", isInteger: Number.isInteger(value), nullable: false };

  if (Array.isArray(value)) {
    if (value.length === 0) return { kind: "array", item: { kind: "any", nullable: false }, nullable: false };
    const merged = value.map(inferSchema).reduce<Schema>((acc, cur) => mergeSchemas(acc, cur), { kind: "null", nullable: true });
    return { kind: "array", item: merged.kind === "null" ? { kind: "any", nullable: true } : merged, nullable: false };
  }

  if (isRecord(value)) {
    const fields: Record<string, Schema> = {};
    for (const [k, v] of Object.entries(value)) fields[k] = inferSchema(v);
    return { kind: "object", fields, nullable: false };
  }

  return { kind: "any", nullable: false };
};

const kotlinKeywords = new Set([
  "as",
  "break",
  "class",
  "continue",
  "do",
  "else",
  "false",
  "for",
  "fun",
  "if",
  "in",
  "interface",
  "is",
  "null",
  "object",
  "package",
  "return",
  "super",
  "this",
  "throw",
  "true",
  "try",
  "typealias",
  "val",
  "var",
  "when",
  "while",
]);

const toPascal = (input: string) => {
  const parts = input
    .trim()
    .replace(/[^a-zA-Z0-9]+/g, " ")
    .split(" ")
    .filter(Boolean);
  let out = parts.map((p) => p.charAt(0).toUpperCase() + p.slice(1)).join("");
  out = out.replace(/^[^A-Za-z_]+/, "");
  if (!out) out = "AutoGenerated";
  if (/^[0-9]/.test(out)) out = `Type${out}`;
  if (kotlinKeywords.has(out)) out = `${out}Dto`;
  return out;
};

const toCamel = (input: string) => {
  const pascal = toPascal(input);
  const out = pascal.charAt(0).toLowerCase() + pascal.slice(1);
  if (kotlinKeywords.has(out)) return `${out}_`;
  return out;
};

type FieldDef = { jsonKey: string; name: string; type: string; needsSerialName: boolean };
type ClassDef = { name: string; fields: FieldDef[] };

type EmitCtx = { usedTypeNames: Set<string>; order: string[]; classes: Map<string, ClassDef> };

const uniqueTypeName = (ctx: EmitCtx, desired: string) => {
  const base = desired || "AutoGenerated";
  if (!ctx.usedTypeNames.has(base)) {
    ctx.usedTypeNames.add(base);
    return base;
  }
  let i = 2;
  while (ctx.usedTypeNames.has(`${base}${i}`)) i += 1;
  const next = `${base}${i}`;
  ctx.usedTypeNames.add(next);
  return next;
};

const ensureClass = (
  ctx: EmitCtx,
  desiredName: string,
  schema: Extract<Schema, { kind: "object" }>,
  opts: { annotation: Annotation },
) => {
  const name = uniqueTypeName(ctx, desiredName);
  if (ctx.classes.has(name)) return name;

  const usedFieldNames = new Set<string>();
  const fields: FieldDef[] = Object.keys(schema.fields)
    .sort()
    .map((jsonKey) => {
      const child = schema.fields[jsonKey] ?? { kind: "any", nullable: true };
      const baseName =
        opts.annotation === "none"
          ? `\`${jsonKey.replace(/`/g, "_")}\``
          : (() => {
              const camel = toCamel(jsonKey);
              const safe = camel || "field";
              const keywordSafe = kotlinKeywords.has(safe) ? `${safe}_` : safe;
              return keywordSafe;
            })();

      let candidate = baseName;
      let i = 2;
      while (usedFieldNames.has(candidate)) {
        candidate = `${baseName}${i}`;
        i += 1;
      }
      usedFieldNames.add(candidate);

      const propNameForCompare = candidate.replace(/^`|`$/g, "");
      const childType = typeFromSchema(child, `${name}${toPascal(jsonKey)}`, ctx, opts);
      const needsSerialName = opts.annotation === "kotlinx" && jsonKey !== propNameForCompare;
      return { jsonKey, name: candidate, type: childType, needsSerialName };
    });

  ctx.classes.set(name, { name, fields });
  ctx.order.push(name);
  return name;
};

const typeFromSchema = (schema: Schema, typeNameHint: string, ctx: EmitCtx, opts: { annotation: Annotation }): string => {
  const base = (() => {
    if (schema.kind === "string") return "String";
    if (schema.kind === "boolean") return "Boolean";
    if (schema.kind === "number") return schema.isInteger ? "Long" : "Double";
    if (schema.kind === "null") return "Any";
    if (schema.kind === "any") return "Any";
    if (schema.kind === "array") {
      const item = typeFromSchema(schema.item, `${typeNameHint}Item`, ctx, opts);
      return `List<${item}>`;
    }
    if (schema.kind === "object") return ensureClass(ctx, toPascal(typeNameHint), schema, opts);
    return "Any";
  })();

  const nullable = schema.nullable;
  return nullable ? `${base}?` : base;
};

const escapeKotlinString = (value: string) => value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');

const generateKotlin = (value: unknown, rootName: string, opts: { annotation: Annotation }) => {
  const ctx: EmitCtx = { usedTypeNames: new Set<string>(), order: [], classes: new Map<string, ClassDef>() };
  const rootTypeName = toPascal(rootName || "AutoGenerated");
  const schema = inferSchema(value);

  const wrapped: Schema = (() => {
    if (schema.kind === "object") return schema;
    if (schema.kind === "array") return { kind: "object", nullable: false, fields: { items: { ...schema, nullable: false } } };
    return { kind: "object", nullable: false, fields: { value: schema } };
  })();

  ensureClass(ctx, rootTypeName, wrapped as Extract<Schema, { kind: "object" }>, opts);

  const usesSerialName = opts.annotation === "kotlinx" && Array.from(ctx.classes.values()).some((c) => c.fields.some((f) => f.needsSerialName));
  const imports: string[] = [];
  if (opts.annotation === "kotlinx") {
    imports.push("import kotlinx.serialization.Serializable");
    if (usesSerialName) imports.push("import kotlinx.serialization.SerialName");
  }

  const lines: string[] = [];
  if (imports.length > 0) lines.push(imports.join("\n"), "");

  for (const name of ctx.order) {
    const def = ctx.classes.get(name);
    if (!def) continue;

    if (opts.annotation === "kotlinx") lines.push("@Serializable");
    lines.push(`data class ${def.name}(`);
    const fieldLines = def.fields.map((f) => {
      const prefix = f.needsSerialName ? `  @SerialName("${escapeKotlinString(f.jsonKey)}")\n` : "  ";
      return `${prefix}val ${f.name}: ${f.type}`;
    });
    lines.push(fieldLines.join(",\n"));
    lines.push(")", "");
  }

  return lines.join("\n").trim();
};

export default function JsonToKotlinDataClassClient() {
  const [rootName, setRootName] = useState("AutoGenerated");
  const [annotation, setAnnotation] = useState<Annotation>("kotlinx");
  const [input, setInput] = useState('{\n  "id": 1,\n  "name": "Alice",\n  "tags": ["a", "b"],\n  "profile": { "email": "a@example.com" }\n}\n');

  const result = useMemo(() => {
    const trimmed = input.trim();
    if (!trimmed) return { ok: true as const, code: "" };
    const parsed = safeJsonParse(trimmed);
    if (parsed === null && trimmed !== "null") return { ok: false as const, error: "JSON 解析失败，请检查格式。" };
    try {
      return { ok: true as const, code: generateKotlin(parsed, rootName, { annotation }) };
    } catch (e) {
      return { ok: false as const, error: e instanceof Error ? e.message : "生成失败" };
    }
  }, [annotation, input, rootName]);

  const formatInput = () => {
    const parsed = safeJsonParse(input);
    if (parsed === null && input.trim() !== "null") return;
    setInput(JSON.stringify(parsed, null, 2));
  };

  const copy = async (value: string) => {
    await navigator.clipboard.writeText(value);
  };

  return (
    <ToolPageLayout toolSlug="json-to-kotlin-data-class">
      <div className="w-full px-4">
        <div className="glass-card rounded-3xl p-6 shadow-2xl ring-1 ring-black/5">
          <div className="flex flex-wrap items-center justify-between gap-3">
            <div className="flex flex-wrap items-center gap-3">
              <label className="flex items-center gap-2 text-sm text-slate-700">
                根类型名
                <input
                  value={rootName}
                  onChange={(e) => setRootName(e.target.value)}
                  className="w-44 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm outline-none focus:border-blue-400 focus:ring-2 focus:ring-blue-400/30"
                />
              </label>
              <label className="flex items-center gap-2 text-sm text-slate-700">
                注解
                <select
                  value={annotation}
                  onChange={(e) => setAnnotation(e.target.value as Annotation)}
                  className="rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm outline-none focus:border-blue-400 focus:ring-2 focus:ring-blue-400/30"
                >
                  <option value="kotlinx">kotlinx.serialization</option>
                  <option value="none">无（字段名尽量与 JSON 一致）</option>
                </select>
              </label>
              <button
                type="button"
                onClick={formatInput}
                className="rounded-xl bg-slate-100 px-3 py-2 text-xs font-medium text-slate-800 transition hover:bg-slate-200"
              >
                格式化 JSON
              </button>
            </div>

            <button
              type="button"
              onClick={() => void copy(result.ok ? result.code : "")}
              disabled={!result.ok || !result.code}
              className="rounded-xl bg-slate-100 px-3 py-2 text-xs font-medium text-slate-800 transition hover:bg-slate-200 disabled:opacity-60"
            >
              复制 Kotlin 代码
            </button>
          </div>

          <div className="mt-6 grid gap-4 lg:grid-cols-2">
            <div>
              <div className="mb-2 text-sm font-semibold text-slate-900">JSON 输入</div>
              <textarea
                value={input}
                onChange={(e) => setInput(e.target.value)}
                className="h-80 w-full resize-none rounded-2xl border border-slate-200 bg-white px-4 py-3 font-mono text-xs text-slate-900 outline-none transition focus:border-blue-400 focus:ring-2 focus:ring-blue-400/30"
              />
              {!result.ok && <div className="mt-2 text-sm text-rose-600">错误：{result.error}</div>}
              <div className="mt-3 text-xs text-slate-500">
                说明：混合类型/混合数组会降级为 <span className="font-mono">Any?</span>；字段缺失/为 null 会生成可空类型。
              </div>
            </div>

            <div>
              <div className="mb-2 text-sm font-semibold text-slate-900">Kotlin 输出</div>
              <textarea
                value={result.ok ? result.code : ""}
                readOnly
                className="h-80 w-full resize-none rounded-2xl border border-slate-200 bg-slate-50 px-4 py-3 font-mono text-xs text-slate-900 outline-none"
              />
            </div>
          </div>
        </div>
      </div>
    </ToolPageLayout>
  );
}
