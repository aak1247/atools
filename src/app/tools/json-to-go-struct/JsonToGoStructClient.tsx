"use client";

import { useMemo, useState } from "react";
import ToolPageLayout from "../../../components/ToolPageLayout";

type StructField = {
  goName: string;
  jsonKey: string;
  goType: string;
  omitEmpty: boolean;
};

type StructDef = {
  name: string;
  fields: StructField[];
};

const safeJsonParse = (text: string): unknown => {
  try {
    return JSON.parse(text);
  } catch {
    return null;
  }
};

const isRecord = (value: unknown): value is Record<string, unknown> =>
  typeof value === "object" && value !== null && !Array.isArray(value);

const goKeywords = new Set([
  "break",
  "default",
  "func",
  "interface",
  "select",
  "case",
  "defer",
  "go",
  "map",
  "struct",
  "chan",
  "else",
  "goto",
  "package",
  "switch",
  "const",
  "fallthrough",
  "if",
  "range",
  "type",
  "continue",
  "for",
  "import",
  "return",
  "var",
]);

const toPascalCase = (input: string) => {
  const parts = input
    .trim()
    .replace(/[^a-zA-Z0-9]+/g, " ")
    .split(" ")
    .filter(Boolean);

  let out = parts
    .map((p) => p.charAt(0).toUpperCase() + p.slice(1))
    .join("")
    .replace(/^[^A-Za-z_]+/, "");

  if (!out) out = "Field";
  if (/^[0-9]/.test(out)) out = `Field${out}`;
  if (goKeywords.has(out.toLowerCase())) out = `${out}_`;
  return out;
};

const classify = (value: unknown) => {
  if (value === null) return "null";
  if (Array.isArray(value)) return "array";
  return typeof value;
};

type Ctx = {
  defs: StructDef[];
  usedNames: Set<string>;
};

const uniqueTypeName = (ctx: Ctx, desired: string) => {
  const name = desired || "AutoGenerated";
  if (!ctx.usedNames.has(name)) {
    ctx.usedNames.add(name);
    return name;
  }
  let i = 2;
  while (ctx.usedNames.has(`${name}${i}`)) i += 1;
  const finalName = `${name}${i}`;
  ctx.usedNames.add(finalName);
  return finalName;
};

const inferPrimitive = (value: unknown): string => {
  if (typeof value === "string") return "string";
  if (typeof value === "boolean") return "bool";
  if (typeof value === "number") return Number.isInteger(value) ? "int64" : "float64";
  if (value === null) return "any";
  return "any";
};

const inferFromValues = (values: unknown[], typeName: string, ctx: Ctx): { goType: string; omitEmpty: boolean } => {
  const nonNull = values.filter((v) => v !== null);
  const omitEmpty = nonNull.length !== values.length;
  if (nonNull.length === 0) return { goType: "any", omitEmpty: true };

  const kinds = new Set(nonNull.map(classify));
  if (kinds.size !== 1) return { goType: "any", omitEmpty };

  const kind = Array.from(kinds)[0];
  if (kind === "object") {
    const name = uniqueTypeName(ctx, typeName);
    buildStructFromObjects(name, nonNull.filter(isRecord), ctx);
    return { goType: name, omitEmpty };
  }
  if (kind === "array") {
    const arrs = nonNull.filter(Array.isArray) as unknown[][];
    const flattened = arrs.flat();
    const item = inferFromValues(flattened, `${typeName}Item`, ctx);
    return { goType: `[]${item.goType}`, omitEmpty };
  }
  return { goType: inferPrimitive(nonNull[0]), omitEmpty };
};

const buildStructFromObjects = (name: string, objects: Array<Record<string, unknown>>, ctx: Ctx) => {
  if (ctx.defs.some((d) => d.name === name)) return;

  const keys = Array.from(new Set(objects.flatMap((o) => Object.keys(o)))).sort();
  const fields: StructField[] = keys.map((key) => {
    const values = objects.map((o) => (Object.prototype.hasOwnProperty.call(o, key) ? o[key] : null));
    const fieldType = inferFromValues(values, `${name}${toPascalCase(key)}`, ctx);
    return {
      goName: toPascalCase(key),
      jsonKey: key,
      goType: fieldType.goType,
      omitEmpty: fieldType.omitEmpty,
    };
  });

  ctx.defs.push({ name, fields });
};

const generateGo = (value: unknown, rootName: string) => {
  const ctx: Ctx = { defs: [], usedNames: new Set<string>() };
  const cleanRootName = toPascalCase(rootName || "AutoGenerated");
  const rootTypeName = uniqueTypeName(ctx, cleanRootName);

  const rootKind = classify(value);
  let rootDecl = "";

  if (rootKind === "object" && isRecord(value)) {
    buildStructFromObjects(rootTypeName, [value], ctx);
    const rootDef = ctx.defs.find((d) => d.name === rootTypeName) ?? null;
    if (!rootDef) throw new Error("生成失败：未找到根结构体定义。");
    rootDecl = `type ${rootTypeName} struct {\n${rootDef.fields
      .map((f) => `  ${f.goName} ${f.goType} \`json:\"${f.jsonKey}${f.omitEmpty ? ",omitempty" : ""}\"\``)
      .join("\n")}\n}`;
    ctx.defs = ctx.defs.filter((d) => d.name !== rootTypeName);
  } else if (rootKind === "array" && Array.isArray(value)) {
    const item = inferFromValues(value, `${rootTypeName}Item`, ctx);
    rootDecl = `type ${rootTypeName} = []${item.goType}`;
  } else {
    rootDecl = `type ${rootTypeName} = ${inferPrimitive(value)}`;
  }

  const nested = ctx.defs
    .map((def) => {
      const body = def.fields
        .map((f) => `  ${f.goName} ${f.goType} \`json:\"${f.jsonKey}${f.omitEmpty ? ",omitempty" : ""}\"\``)
        .join("\n");
      return `type ${def.name} struct {\n${body}\n}`;
    })
    .join("\n\n");

  return [rootDecl, nested].filter(Boolean).join("\n\n");
};

export default function JsonToGoStructClient() {
  const [rootName, setRootName] = useState("AutoGenerated");
  const [input, setInput] = useState('{\n  "id": 1,\n  "name": "Alice",\n  "tags": ["a", "b"],\n  "profile": { "email": "a@example.com" }\n}\n');

  const result = useMemo(() => {
    const trimmed = input.trim();
    if (!trimmed) return { ok: true as const, code: "" };
    const parsed = safeJsonParse(trimmed);
    if (parsed === null && trimmed !== "null") return { ok: false as const, error: "JSON 解析失败，请检查格式。" };
    try {
      return { ok: true as const, code: generateGo(parsed, rootName) };
    } catch (e) {
      return { ok: false as const, error: e instanceof Error ? e.message : "生成失败" };
    }
  }, [input, rootName]);

  const formatInput = () => {
    const parsed = safeJsonParse(input);
    if (parsed === null && input.trim() !== "null") return;
    setInput(JSON.stringify(parsed, null, 2));
  };

  const copy = async (value: string) => {
    await navigator.clipboard.writeText(value);
  };

  return (
    <ToolPageLayout toolSlug="json-to-go-struct">
      <div className="w-full px-4">
        <div className="glass-card rounded-3xl p-6 shadow-2xl ring-1 ring-black/5">
          <div className="flex flex-wrap items-center justify-between gap-3">
            <div className="flex flex-wrap items-center gap-3">
              <label className="flex items-center gap-2 text-sm text-slate-700">
                根类型名
                <input
                  value={rootName}
                  onChange={(e) => setRootName(e.target.value)}
                  className="w-44 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm outline-none focus:border-blue-400 focus:ring-2 focus:ring-blue-400/30"
                />
              </label>
              <button
                type="button"
                onClick={formatInput}
                className="rounded-xl bg-slate-100 px-3 py-2 text-xs font-medium text-slate-800 transition hover:bg-slate-200"
              >
                格式化 JSON
              </button>
            </div>

            <button
              type="button"
              onClick={() => void copy(result.ok ? result.code : "")}
              disabled={!result.ok || !result.code}
              className="rounded-xl bg-slate-100 px-3 py-2 text-xs font-medium text-slate-800 transition hover:bg-slate-200 disabled:opacity-60"
            >
              复制 Go 代码
            </button>
          </div>

          <div className="mt-6 grid gap-4 lg:grid-cols-2">
            <div>
              <div className="mb-2 text-sm font-semibold text-slate-900">JSON 输入</div>
              <textarea
                value={input}
                onChange={(e) => setInput(e.target.value)}
                className="h-80 w-full resize-none rounded-2xl border border-slate-200 bg-white px-4 py-3 font-mono text-xs text-slate-900 outline-none transition focus:border-blue-400 focus:ring-2 focus:ring-blue-400/30"
              />
              {!result.ok && <div className="mt-2 text-sm text-rose-600">错误：{result.error}</div>}
              <div className="mt-3 text-xs text-slate-500">说明：对象字段会生成 JSON Tag，遇到多类型/混合数组会降级为 <span className="font-mono">any</span>。</div>
            </div>

            <div>
              <div className="mb-2 text-sm font-semibold text-slate-900">Go Struct 输出</div>
              <textarea
                value={result.ok ? result.code : ""}
                readOnly
                className="h-80 w-full resize-none rounded-2xl border border-slate-200 bg-slate-50 px-4 py-3 font-mono text-xs text-slate-900 outline-none"
              />
            </div>
          </div>
        </div>
      </div>
    </ToolPageLayout>
  );
}
